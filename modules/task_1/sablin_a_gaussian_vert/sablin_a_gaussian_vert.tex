\documentclass{report}

\usepackage[warn]{mathtext}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{luainputenc}
\usepackage[english, russian]{babel}
\usepackage[pdftex]{hyperref}
\usepackage{tempora}
\usepackage[12pt]{extsizes}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{amsmath}

\geometry{a4paper,top=2cm,bottom=2cm,left=2.5cm,right=1.5cm}
\setlength{\parskip}{0.5cm}
\setlist{nolistsep, itemsep=0.3cm,parsep=0pt}

\usepackage{listings}
\lstset{language=C++,
        basicstyle=\footnotesize,
		keywordstyle=\color{blue}\ttfamily,
		stringstyle=\color{red}\ttfamily,
		commentstyle=\color{green}\ttfamily,
		morecomment=[l][\color{red}]{\#}, 
		tabsize=4,
		breaklines=true,
  		breakatwhitespace=true,
  		title=\lstname,       
}

\makeatletter
\renewcommand\@biblabel[1]{#1.\hfil}
\makeatother

\begin{document}

\begin{titlepage}

\begin{center}
Министерство науки и высшего образования Российской Федерации
\end{center}

\begin{center}
Федеральное государственное автономное образовательное учреждение высшего образования \\
Национальный исследовательский Нижегородский государственный университет им. Н.И. Лобачевского
\end{center}

\begin{center}
Институт информационных технологий, математики и механики
\end{center}

\vspace{4em}

\begin{center}
\textbf{\LargeОтчет по лабораторной работе} \\
\end{center}
\begin{center}
\textbf{\Large«Линейная фильтрация изображений (вертикальное разбиение). Ядро Гаусса 3x3.»} \\
\end{center}

\vspace{4em}

\newbox{\lbox}
\savebox{\lbox}{\hbox{text}}
\newlength{\maxl}
\setlength{\maxl}{\wd\lbox}
\hfill\parbox{7cm}{
\hspace*{5cm}\hspace*{-5cm}\textbf{Выполнил:} \\ студент группы 381906-2 \\ Саблин А.В.\\
\\
\hspace*{5cm}\hspace*{-5cm}\textbf{Проверил:}\\ доцент кафедры МОСТ, \\ кандидат технических наук \\ Сысоев А. В.\\}
\vspace{\fill}

\begin{center} Нижний Новгород \\ 2022 \end{center}

\end{titlepage}

\setcounter{page}{2}

% Содержание
\tableofcontents
\newpage

% Введение
\section*{Введение}
\addcontentsline{toc}{section}{Введение}
\par В современном мире, хоть не так часто, но возникает проблема проявления всякого рода шумов на фотографиях. Эта проблема требует решения, и одно из них это фильтр Гаусса. Существуют и другие подобные фильтры, которые прикрепляются к определенным типам шумов. Гауссова фильтрация очень эффективна для подавления шума, который подчиняется нормальному распределению, за счет размытия изображения. Конечно, иногда целью сглаживания и фильтрации изображения является размытие изображения. Этот фильтр относится к линейным матричным фильтрам и хорошо распараллеливается.
\newpage

% Постановка задачи
\section*{Постановка задачи}
\addcontentsline{toc}{section}{Постановка задачи}
\par В данном лабораторной работе требуется реализовать последовательную версию и параллельные версии алгоритма линейной фильтрации Гаусса (3x3), провести вычислительные эксперименты для сравнения времени работы алгоритмов, используя при этом фрэймворк для разработки автоматических тестов Google Test, продемонстрировать работу алгоритмов на реальных изображениях, сделать выводы об эффективности реализованных алгоритмов.
\par Параллельные алгоритмы должны быть реализованы при помощи технологий OpenMP, TBB, std::thread.
\newpage

% Описание алгоритма
\section*{Описание алгоритма}
\addcontentsline{toc}{section}{Описание алгоритма}
\par Алгоритм линейной растяжки гистограммы состоит из следующих шагов:
\begin{enumerate}
\item Высчитывание ядра Гаусса в зависимости от параметра sigma (не распараллеливается, иначе это займёт больше времени): $$G(x,y) = \frac{1}{2*pi*sigma^2} * -e^\frac{x^2 + y^2}{2*sigma^2}$$
где $x$, $y$ - координаты в ядре Гаусса.
\item Вычисление пиксела будущего изображения, за счёт наложения ядра Гаусса на соответствующий пиксель исходной картинки.\\
Каждый пиксель из окружения (в нашем случае 3x3) будет вкладываться в результат тем больше, чем ближе к центру он находится. Это определяется за счёт коэффициентов ядра, которые были вычислены шаг назад.
\end{enumerate}
\newpage

% Описание схемы распараллеливания
\section*{Описание схемы распараллеливания}
\addcontentsline{toc}{section}{Описание схемы распараллеливания}
\par Распараллеливание происходит с помощью разбиения изображения (т.е. массива пикселей) на столбцы влияния и распределения их между потоками. Каждый созднанный поток обрабатывает свою часть изображения. А именно применяет ядро Гаусса к своей части изображения. В OpenMP и TBB версиях распределение данных осуществляется автоматически. Кол-во потоков в каждой из версий определяется автоматически. В std::thread версии количество данных, обрабатываемое каждым потоком, определяется по формуле $\frac{\text{число столбцов}}{\text{число потоков}}$. А так же учитывается наличие остатка, который уменьшается с каждой итерацией, добавлением своей части очередному потоку. Параллелизация происходит на уровне цикла for. При выходе из параллельного региона во всех параллельных версиях используется автоматическая синхронизация.

\newpage

% Описание программной реализации
\section*{Описание программной реализации}
\addcontentsline{toc}{section}{Описание программной реализации}
Программа состоит из заголовочного файла gaussian\_vert.h и двух файлов исходного кода gaussian\_vert.cpp и main.cpp.
\par В заголовочном файле находятся прототипы функций для последовательного и параллельных алгоритмов линейной фильтрации изображения.
\par Структура пикселя (скаляр вектора изображения)
\begin{lstlisting}
struct rgb_coub {
  unsigned char red, green, blue;
};
\end{lstlisting}
\par Перегрузки операторов для работы тестов и сравнения векторов <rgb\_coub> объектов
\begin{lstlisting}
bool operator==(const rgb_coub& a, const rgb_coub& b);
bool operator!=(const rgb_coub& a, const rgb_coub& b);
\end{lstlisting}
\par Функция для представления изображения:
\begin{lstlisting}
std::vector<rgb_coub> getRandomImage(int rows, int columns);
\end{lstlisting}
Где параметрами являются кол-во рядов и столбцов изображения (\_x\_)
\par Функция для последовательного алгоритма:
\begin{lstlisting}
std::vector<rgb_coub> Gaussian_Filter_Seq(const std::vector<rgb_coub>& img,
                                          int rows, int columns,
                                          const double sigma);
\end{lstlisting}
Первый параметр функции является массивом пикселей изображения, второй и третий - размеры изображения, четвертый - число sigma.
\par Функция для параллельного алгоритма (OpenMP версия):
\begin{lstlisting}
std::vector<rgb_coub> Gaussian_Filter_Omp(const std::vector<rgb_coub>& img,
                                          int rows, int columns,
                                          const double sigma);
\end{lstlisting}
\par Функция для параллельного алгоритма (TBB версия):
\begin{lstlisting}
std::vector<rgb_coub> Gaussian_Filter_Tbb(const std::vector<rgb_coub>& img,
                                          int rows, int columns,
                                          const double sigma);
\end{lstlisting}
\par Функция для параллельного алгоритма (std::thread версия):
\begin{lstlisting}
std::vector<rgb_coub> Gaussian_Filter_Thread(const std::vector<rgb_coub>& img,
                                          int rows, int columns,
                                          const double sigma);
\end{lstlisting}
Параметры для этих функций совпадают с параметрами Seq - функции.
\newpage

% Подтверждение корректности
\section*{Подтверждение корректности}
\addcontentsline{toc}{section}{Подтверждение корректности}
Были проведены тесты на реальных изображениях. Визуализация осуществлялась с помощью средств библиотеки OpenCV. При чрезмерном использовании таких фильтров картинка характерно размывается. Таким образом мы сможем точно определить правильность или неправильность исполнения фильтра. Тестовая программа выведет три иозбражения - Original, Sequential, Parallel. Всеми алгоритмами были достигнуты правильные результаты коррекции изображений.
\par Для подтверждения корректности работы данной программы с помощью фрэймфорка Google Test было разработано 5 тестов для каждой версии алгоритма. В одном из тестов проверяется корректность работы выдачи ошибок, например, если подан массив (картинка) с нулями столбцов, то должна быть выведена ошибка. В последующих трёх тестах сравниваются результаты работы параллельных алгоритмов с последовательным - на изображении, полученном функцией подбора случайного изображения. В последнем тесте явно указывается изображение (в виде вектора) и точный результат работы фильтра Гаусса, с которым и сравнивается сделанный параллельный алгоритм.
\par Успешное прохождение всех тестов подтверждает корректность работы программы.
\newpage

% Результаты экспериментов
\section*{Результаты экспериментов}
\addcontentsline{toc}{section}{Результаты экспериментов}
Вычислительные эксперименты для оценки эффективности работы параллельных алгоритмов проводились на ПК со следующими характеристиками:
\begin{itemize}
\item Процессор: Intel Сore i5 9300-H: 2.4 GHz, Кол-во ядер: 4, Кол-во потоков: 8;
\item Оперативная память: 8 ГБ;
\item Операционная система: Windows 10 Professional x64.
\end{itemize}

\par Эксперименты проводились на 8 потоках (автоматически высчитано библиотеками). Размеры изображений равны 600x400, 1680x1120, 4000x2667 пикселей.

\par Результаты экспериментов представлены.
\begin{table}[!h]
\caption{Результаты вычислительных экспериментов с изображением 600x400}
\centering
\begin{tabular}{| p{5cm} | p{5cm} | p{5cm} |}
\hline
Версия алгоритма & Время работы (в секундах) & Ускорение  \\[5pt]
\hline
Sequential      & 0.115537       & -         \\
OpenMP        & 0.062027        & 1.862688          \\
TBB       & 0.062527       & 1.847792         \\
std::thread        & 0.055712        & 2.073826          \\
\hline
\end{tabular}
\end{table}

\begin{table}[!h]
\caption{Результаты вычислительных экспериментов с изображением 1680x1120}
\centering
\begin{tabular}{| p{5cm} | p{5cm} | p{5cm} |}
\hline
Версия алгоритма & Время работы (в секундах) & Ускорение  \\[5pt]
\hline
Sequential        & 0.93061        & -         \\
OpenMP        & 0.24748        & 3.76034          \\
TBB       & 0.25123        & 3.70422         \\
std::thread        & 0.23722        & 3.92298           \\
\hline
\end{tabular}
\end{table}

\begin{table}[!h]
\caption{Результаты вычислительных экспериментов с изображением 4000x2667}
\centering
\begin{tabular}{| p{5cm} | p{5cm} | p{5cm} |}
\hline
Версия алгоритма & Время работы (в секундах) & Ускорение  \\[5pt]
\hline
Sequential        & 4.68285        & -         \\
OpenMP        & 1.34622        & 3.47852          \\
TBB       & 1.33312        & 3.51269        \\
std::thread        & 1.31982        & 3.54809           \\
\hline
\end{tabular}
\end{table}

\begin{table}[!h]
\caption{Результаты вычислительных экспериментов с изображением 1680x1120 с ядром Гаусса 7x7}
\centering
\begin{tabular}{| p{5cm} | p{5cm} | p{5cm} |}
\hline
Версия алгоритма & Время работы (в секундах) & Ускорение  \\[5pt]
\hline
Sequential        & 4.19917        & -         \\
OpenMP        & 0.997024        & 4.211704          \\
TBB       & 0.933212        & 4.499695         \\
std::thread        & 0.908201        & 4.623613           \\
\hline
\end{tabular}
\end{table}

\newpage

% Выводы из результатов экспериментов
\section*{Выводы из результатов экспериментов}
\addcontentsline{toc}{section}{Выводы из результатов экспериментов}
Из данных, полученных в результате экспериментов (см. Таблицы 1, 2, 3), можно сделать вывод, что все параллельные версии работают намного быстрее, чем последовательная. Проанализировав полученные результаты, можно заметить, что std::thread версий версия работает быстрее чем OpenMP и TBB версий. Так же можно заметить, что ускорение приближается к 4 (числу ядер). А в случае с ядром Гаусса - 7x7: Ускорение переваливает за 4.
\newpage

% Заключение
\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}
Таким образом, в рамках данной лабораторной работы были разработаны последовательный и параллельные алгоритмы линейной фильтрации Гаусса (3x3). Проведенные тесты показали корректность реализованной программы, а проведенные эксперименты доказали эффективность параллельных алгоритмов по сравнению с последовательным.
\newpage

% Литература
\section*{Литература}
\addcontentsline{toc}{section}{Литература}
\begin{enumerate}
\item OpenCV - Электронный ресурс. URL: \newline \url{https://docs.opencv.org/}
\item Habr - Электронный ресурс. URL: \newline \url{https://habr.com/ru/post/151157/}
\item Е.В. Турлапов «Обработка изображений. Часть 2». URL: \newline \url{http://www.graph.unn.ru/rus/materials/CG/CG04_ImageProcessing2.pdf}
\item Educative - Электронный ресурс. URL: \newline \url{https://www.educative.io/blog/modern-multithreading-and-concurrency-in-cpp}
\item А.В. Сысоев, И.Б. Мееров, А.А. Сиднев «Средства разработки параллельных программ для систем с общей памятью. Библиотека Intel Threading Building Blocks». Нижний Новгород, 2007, 128 с. 
\item А.В. Сысоев, И.Б. Мееров, А.Н. Свистунов, А.Л. Курылев, А.В. Сенин, А.В. Шишков, К.В. Корняков, А.А. Сиднев «Параллельное программирование в системах с общей
памятью. Инструментальная поддержка». Нижний Новгород, 2007, 110 с. 
\end{enumerate} 
\newpage

% Приложение
\section*{Приложение}
\addcontentsline{toc}{section}{Приложение}
\textbf{Последовательная версия}
\newline
\newline gaussian\_vert.cpp
\begin{lstlisting}
// Copyright 2022 Sablin Alexandr
#ifndef MODULES_TASK_1_SABLIN_A_GAUSSIAN_VERT_GAUSSIAN_VERT_H_
#define MODULES_TASK_1_SABLIN_A_GAUSSIAN_VERT_GAUSSIAN_VERT_H_

#include <vector>
#include <random>
#include <iostream>

struct rgb_coub {
    unsigned char red, green, blue;
};
bool operator==(const rgb_coub& a, const rgb_coub& b);
std::vector<rgb_coub> getRandomImage(int rows, int columns);
std::vector<rgb_coub> Gaussian_Filter_Seq(const std::vector<rgb_coub>& img,
    int rows, int columns, const double sigma);

#endif  // MODULES_TASK_1_SABLIN_A_GAUSSIAN_VERT_GAUSSIAN_VERT_H_

\end{lstlisting}
gaussian\_vert.cpp
\begin{lstlisting}
// Copyright 2022 Sablin Alexandr
#include <vector>
#include <random>
#include "../../../modules/task_1/sablin_a_gaussian_vert/gaussian_vert.h"

bool operator==(const rgb_coub& a, const rgb_coub& b) {
    return (a.red == b.red) && (a.green == b.green) && (a.blue == b.blue);
}

std::vector<rgb_coub> getRandomImage(int rows, int columns) {
    if (columns <= 0 || rows <= 0) {
        throw "-1";
    }
    std::random_device dev;
    std::mt19937 gen(dev());
    std::vector<rgb_coub> data(rows * columns);
    for (int i = 0; i < rows * columns; i++) {
      data[i].red = static_cast<unsigned char>(gen() % 256);
      data[i].green = static_cast<unsigned char>(gen() % 256);
      data[i].blue = static_cast<unsigned char>(gen() % 256);
    }
    return data;
}

std::vector<rgb_coub> Gaussian_Filter_Seq(const std::vector<rgb_coub>& img,
    int rows, int columns, const double sigma) {
    if (columns <= 0 || rows <= 0 || img.size() == 0 || sigma == 0.0) {
        throw "-1";
    }
    double norm = 0.0;
    double r, g, b;
    double Gaussian_Kernel[3][3];
    for (int x = -1; x < 2; x++) {
        for (int y = -1; y < 2; y++) {
            Gaussian_Kernel[x + 1][y + 1] = std::exp(-(x * x + y * y) / (2 * pow(sigma, 2)));
            norm += Gaussian_Kernel[x + 1][y + 1];
        }
    }
    for (int x = -1; x < 2; x++) {
        for (int y = -1; y < 2; y++) {
            Gaussian_Kernel[x + 1][y + 1] /= norm;
        }
    }
    std::vector<rgb_coub> result(rows * columns);
    int x, y;
    for (int i = 0; i < columns; i++) {
        for (int j = 0; j < rows; j++) {
            r = g = b = 0.0;
            for (int k = -1; k < 2; k++) {
                for (int n = -1; n < 2; n++) {
                    x = n + j;
                    y = k + i;

                    if (x > rows - 1 || x < 0) {
                        x = j;
                    }
                    if (y > columns - 1 || y < 0) {
                        y = i;
                    }
                    r += static_cast<double>(img[x * columns + y].red) *
                         Gaussian_Kernel[k + 1][n + 1];
                    g += static_cast<double>(img[x * columns + y].green) *
                         Gaussian_Kernel[k + 1][n + 1];
                    b += static_cast<double>(img[x * columns + y].blue) *
                         Gaussian_Kernel[k + 1][n + 1];
                }
            }
            result[j * columns + i].red = static_cast<unsigned char>(r);
            result[j * columns + i].green = static_cast<unsigned char>(g);
            result[j * columns + i].blue = static_cast<unsigned char>(b);
        }
    }
    return result;
}
\end{lstlisting}
main.cpp
\begin{lstlisting}
// Copyright 2022 Sablin Alexandr
#include <gtest/gtest.h>
#include <algorithm>
#include "../../../modules/task_1/sablin_a_gaussian_vert/gaussian_vert.h"

TEST(Gaussian_Filter_vertical, Test_Zero_Pixels_and_Sigma) {
    std::vector<rgb_coub> img = getRandomImage(1, 1);
    EXPECT_ANY_THROW(Gaussian_Filter_Seq(img, 0, 0, 1));
    EXPECT_ANY_THROW(Gaussian_Filter_Seq(img, 0, 1, 1));
    EXPECT_ANY_THROW(Gaussian_Filter_Seq(img, 1, 0, 1));
    EXPECT_ANY_THROW(Gaussian_Filter_Seq(img, 1, 1, 0));
    EXPECT_ANY_THROW(getRandomImage(0, 0));
}

TEST(Gaussian_Filter_vertical, Test_Different_Rows_and_Columns) {
    int rows = 120, columns = 2;
    const double sigma = 2.0;
    std::vector<rgb_coub> image = getRandomImage(rows, columns);
    std::vector<rgb_coub> res = Gaussian_Filter_Seq(image, rows, columns, sigma);
    ASSERT_NE(image, res);
}

TEST(Gaussian_Filter_vertical, Test_Big_Image) {
    int rows = 300, columns = 300;
    const double sigma = 2.0;
    std::vector<rgb_coub> image = getRandomImage(rows, columns);
    std::vector<rgb_coub> res = Gaussian_Filter_Seq(image, rows, columns, sigma);
    ASSERT_NE(res, image);
}

TEST(Gaussian_Filter_vertical, Test_One_Pixel) {
    int rows = 1, columns = 1;
    const double sigma = 2.0;
    std::vector<rgb_coub> image = getRandomImage(rows, columns);
    std::vector<rgb_coub> copy(image);
    image = Gaussian_Filter_Seq(image, rows, columns, sigma);
    ASSERT_EQ(image, copy);
}

TEST(Gaussian_Filter_vertical, Test_Const_Image) {
    int rows = 3, columns = 3;
    const double sigma = 2.0;
    std::vector<rgb_coub> true_result(rows * columns);
    true_result[0].red = true_result[0].green = true_result[0].blue = 85;
    true_result[1].red = true_result[1].green = true_result[1].blue = 99;
    true_result[2].red = true_result[2].green = true_result[2].blue = 112;
    true_result[3].red = true_result[3].green = true_result[3].blue = 126;
    true_result[4].red = true_result[4].green = true_result[4].blue = 140;
    true_result[5].red = true_result[5].green = true_result[5].blue = 153;
    true_result[6].red = true_result[6].green = true_result[6].blue = 167;
    true_result[7].red = true_result[7].green = true_result[7].blue = 180;
    true_result[8].red = true_result[8].green = true_result[8].blue = 194;
    std::vector<rgb_coub> image(rows * columns);
    for (int i = 0; i < rows * columns; i++) {
        image[i].red = 60 + i * 20;
        image[i].green = 60 + i * 20;
        image[i].blue = 60 + i * 20;
    }
    image = Gaussian_Filter_Seq(image, rows, columns, sigma);
    ASSERT_EQ(image, true_result);
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
    return 0;
}
\end{lstlisting}

\textbf{OpenMP версия}
\newline
\newline gaussian\_vert.h
\begin{lstlisting}
// Copyright 2022 Sablin Alexandr
#ifndef MODULES_TASK_2_SABLIN_A_GAUSSIAN_VERT_GAUSSIAN_VERT_H_
#define MODULES_TASK_2_SABLIN_A_GAUSSIAN_VERT_GAUSSIAN_VERT_H_

#include <omp.h>
#include <iostream>
#include <random>
#include <vector>

struct rgb_coub {
  unsigned char red, green, blue;
};
bool operator==(const rgb_coub& a, const rgb_coub& b);
bool operator!=(const rgb_coub& a, const rgb_coub& b);
std::vector<rgb_coub> getRandomImage(int rows, int columns);
std::vector<rgb_coub> Gaussian_Filter_Seq(const std::vector<rgb_coub>& img,
                                          int rows, int columns,
                                          const double sigma);
std::vector<rgb_coub> Gaussian_Filter_Omp(const std::vector<rgb_coub>& img,
                                          int rows, int columns,
                                          const double sigma);

#endif  // MODULES_TASK_2_SABLIN_A_GAUSSIAN_VERT_GAUSSIAN_VERT_H_


\end{lstlisting}
gaussian\_vert.cpp
\begin{lstlisting}
// Copyright 2022 Sablin Alexandr
#include "../../../modules/task_2/sablin_a_gaussian_vert/gaussian_vert.h"

bool operator==(const rgb_coub& a, const rgb_coub& b) {
  return (a.red == b.red) && (a.green == b.green) && (a.blue == b.blue);
}

bool operator!=(const rgb_coub& a, const rgb_coub& b) {
  return (a.red != b.red) && (a.green != b.green) && (a.blue != b.blue);
}

std::vector<rgb_coub> getRandomImage(int rows, int columns) {
  if (columns <= 0 || rows <= 0) {
    throw "-1";
  }
  std::random_device dev;
  std::mt19937 gen(dev());
  std::vector<rgb_coub> data(rows * columns);
  for (int i = 0; i < rows * columns; i++) {
    data[i].red = static_cast<unsigned char> (gen() % 256);
    data[i].green = static_cast<unsigned char> (gen() % 256);
    data[i].blue = static_cast<unsigned char> (gen() % 256);
  }
  return data;
}
std::vector<rgb_coub> Gaussian_Filter_Seq(const std::vector<rgb_coub>& img,
                                          int rows, int columns,
                                          const double sigma) {
  if (columns <= 0 || rows <= 0 || img.size() == 0 || sigma == 0.0) {
    throw "-1";
  }
  double norm = 0.0;
  double r, g, b;
  double Gaussian_Kernel[3][3];
  for (int x = -1; x < 2; x++) {
    for (int y = -1; y < 2; y++) {
      Gaussian_Kernel[x + 1][y + 1] =
          std::exp(-(x * x + y * y) / (2 * pow(sigma, 2)));
      norm += Gaussian_Kernel[x + 1][y + 1];
    }
  }
  for (int x = -1; x < 2; x++) {
    for (int y = -1; y < 2; y++) {
      Gaussian_Kernel[x + 1][y + 1] /= norm;
    }
  }
  std::vector<rgb_coub> result(rows * columns);
  int x, y;
  for (int i = 0; i < columns; i++) {
    for (int j = 0; j < rows; j++) {
      r = g = b = 0.0;
      for (int k = -1; k < 2; k++) {
        for (int n = -1; n < 2; n++) {
          x = n + j;
          y = k + i;

          if (x > rows - 1 || x < 0) {
            x = j;
          }
          if (y > columns - 1 || y < 0) {
            y = i;
          }
          r += static_cast<double>(img[x * columns + y].red) *
               Gaussian_Kernel[k + 1][n + 1];
          g += static_cast<double>(img[x * columns + y].green) *
               Gaussian_Kernel[k + 1][n + 1];
          b += static_cast<double>(img[x * columns + y].blue) *
               Gaussian_Kernel[k + 1][n + 1];
        }
      }
      result[j * columns + i].red = static_cast<unsigned char>(r);
      result[j * columns + i].green = static_cast<unsigned char>(g);
      result[j * columns + i].blue = static_cast<unsigned char>(b);
    }
  }
  return result;
}

std::vector<rgb_coub> Gaussian_Filter_Omp(const std::vector<rgb_coub>& img,
                                          int rows, int columns,
                                          const double sigma) {
  if (columns <= 0 || rows <= 0 || img.size() == 0 || sigma == 0.0) {
    throw "-1";
  }
  double norm = 0.0;
  double r, g, b;
  double Gaussian_Kernel[3][3];
  for (int x = -1; x < 2; x++) {
    for (int y = -1; y < 2; y++) {
      Gaussian_Kernel[x + 1][y + 1] =
          std::exp(-(x * x + y * y) / (2 * pow(sigma, 2)));
      norm += Gaussian_Kernel[x + 1][y + 1];
    }
  }
  for (int x = -1; x < 2; x++) {
    for (int y = -1; y < 2; y++) {
      Gaussian_Kernel[x + 1][y + 1] /= norm;
    }
  }
  std::vector<rgb_coub> result(rows * columns);
  int x, y;
#pragma omp parallel for private(r, g, b, x, y)
  for (int i = 0; i < columns; i++) {
    for (int j = 0; j < rows; j++) {
      r = g = b = 0.0;
      for (int k = -1; k < 2; k++) {
        for (int n = -1; n < 2; n++) {
          x = n + j;
          y = k + i;

          if (x > rows - 1 || x < 0) {
            x = j;
          }
          if (y > columns - 1 || y < 0) {
            y = i;
          }
          r += static_cast<double> (img[x * columns + y].red) *
               Gaussian_Kernel[k + 1][n + 1];
          g += static_cast<double> (img[x * columns + y].green) *
               Gaussian_Kernel[k + 1][n + 1];
          b += static_cast<double> (img[x * columns + y].blue) *
               Gaussian_Kernel[k + 1][n + 1];
        }
      }
      result[j * columns + i].red = static_cast<unsigned char>(r);
      result[j * columns + i].green = static_cast<unsigned char>(g);
      result[j * columns + i].blue = static_cast<unsigned char>(b);
    }
  }
  return result;
}
\end{lstlisting}
main.cpp
\begin{lstlisting}
// Copyright 2022 Sablin Alexandr
#include <gtest/gtest.h>

#include <algorithm>

#include "../../../modules/task_2/sablin_a_gaussian_vert/gaussian_vert.h"

TEST(Gaussian_Filter_vertical, Test_Zero_Pixels_and_Sigma) {
  std::vector<rgb_coub> img = getRandomImage(1, 1);
  EXPECT_ANY_THROW(Gaussian_Filter_Omp(img, 0, 0, 1));
  EXPECT_ANY_THROW(Gaussian_Filter_Omp(img, 0, 1, 1));
  EXPECT_ANY_THROW(Gaussian_Filter_Omp(img, 1, 0, 1));
  EXPECT_ANY_THROW(Gaussian_Filter_Omp(img, 1, 1, 0));
  EXPECT_ANY_THROW(getRandomImage(0, 0));
}

TEST(Gaussian_Filter_vertical, Test_Different_Rows_and_Columns) {
  int rows = 120, columns = 8;
  const double sigma = 2.0;
  std::vector<rgb_coub> image = getRandomImage(rows, columns);
  double t1 = omp_get_wtime();
  std::vector<rgb_coub> res1 = Gaussian_Filter_Seq(image, rows, columns, sigma);
  double t2 = omp_get_wtime();
  std::vector<rgb_coub> res2 = Gaussian_Filter_Omp(image, rows, columns, sigma);
  double t3 = omp_get_wtime();
  printf("Time Seq: %lf\n", t2 - t1);
  printf("Time Omp: %lf\n", t3 - t2);
  printf("Efficiency: %lf\n", (t2 - t1) / (t3 - t2));
  ASSERT_EQ(res1, res2);
}

TEST(Gaussian_Filter_vertical, Test_Big_Image) {
  int rows = 300, columns = 300;
  const double sigma = 2.0;
  std::vector<rgb_coub> image = getRandomImage(rows, columns);
  double t1 = omp_get_wtime();
  std::vector<rgb_coub> res1 = Gaussian_Filter_Seq(image, rows, columns, sigma);
  double t2 = omp_get_wtime();
  std::vector<rgb_coub> res2 = Gaussian_Filter_Omp(image, rows, columns, sigma);
  double t3 = omp_get_wtime();
  printf("Time Seq: %lf\n", t2 - t1);
  printf("Time Omp: %lf\n", t3 - t2);
  printf("Efficiency: %lf\n", (t2 - t1) / (t3 - t2));
  ASSERT_EQ(res1, res2);
}

TEST(Gaussian_Filter_vertical, Test_One_Pixel) {
  int rows = 1, columns = 1;
  const double sigma = 2.0;
  std::vector<rgb_coub> image = getRandomImage(rows, columns);
  std::vector<rgb_coub> copy(image);
  image = Gaussian_Filter_Seq(image, rows, columns, sigma);
  ASSERT_EQ(image, copy);
}

TEST(Gaussian_Filter_vertical, Test_Const_Image) {
  int rows = 3, columns = 3;
  const double sigma = 2.0;
  std::vector<rgb_coub> true_result(rows * columns);
  true_result[0].red = true_result[0].green = true_result[0].blue = 85;
  true_result[1].red = true_result[1].green = true_result[1].blue = 99;
  true_result[2].red = true_result[2].green = true_result[2].blue = 112;
  true_result[3].red = true_result[3].green = true_result[3].blue = 126;
  true_result[4].red = true_result[4].green = true_result[4].blue = 140;
  true_result[5].red = true_result[5].green = true_result[5].blue = 153;
  true_result[6].red = true_result[6].green = true_result[6].blue = 167;
  true_result[7].red = true_result[7].green = true_result[7].blue = 180;
  true_result[8].red = true_result[8].green = true_result[8].blue = 194;
  std::vector<rgb_coub> image(rows * columns);
  for (int i = 0; i < rows * columns; i++) {
    image[i].red = 60 + i * 20;
    image[i].green = 60 + i * 20;
    image[i].blue = 60 + i * 20;
  }
  image = Gaussian_Filter_Omp(image, rows, columns, sigma);
  ASSERT_EQ(image, true_result);
}

int main(int argc, char** argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
  return 0;
}

\end{lstlisting}

\textbf{TBB версия}
\newline
\newline gaussian\_vert.h
\begin{lstlisting}
// Copyright 2022 Sablin Alexandr
#ifndef MODULES_TASK_3_SABLIN_A_GAUSSIAN_VERT_GAUSSIAN_VERT_H_
#define MODULES_TASK_3_SABLIN_A_GAUSSIAN_VERT_GAUSSIAN_VERT_H_

#include <tbb/tbb.h>
#include <tbb/parallel_for.h>
#include <tbb/blocked_range.h>

#include <ctime>
#include <iostream>
#include <random>
#include <vector>

struct rgb_coub {
  unsigned char red, green, blue;
};
bool operator==(const rgb_coub& a, const rgb_coub& b);
bool operator!=(const rgb_coub& a, const rgb_coub& b);
std::vector<rgb_coub> getRandomImage(int rows, int columns);
std::vector<rgb_coub> Gaussian_Filter_Seq(const std::vector<rgb_coub>& img,
                                          int rows, int columns,
                                          const double sigma);
std::vector<rgb_coub> Gaussian_Filter_Tbb(const std::vector<rgb_coub>& img,
                                          int rows, int columns,
                                          const double sigma);

#endif  // MODULES_TASK_3_SABLIN_A_GAUSSIAN_VERT_GAUSSIAN_VERT_H_


\end{lstlisting}
gaussian\_vert.cpp
\begin{lstlisting}
// Copyright 2022 Sablin Alexandr
#include "../../../modules/task_3/sablin_a_gaussian_vert/gaussian_vert.h"

bool operator==(const rgb_coub& a, const rgb_coub& b) {
  return (a.red == b.red) && (a.green == b.green) && (a.blue == b.blue);
}

bool operator!=(const rgb_coub& a, const rgb_coub& b) {
  return (a.red != b.red) && (a.green != b.green) && (a.blue != b.blue);
}

std::vector<rgb_coub> getRandomImage(int rows, int columns) {
  if (columns <= 0 || rows <= 0) {
    throw "-1";
  }
  std::random_device dev;
  std::mt19937 gen(dev());
  std::vector<rgb_coub> data(rows * columns);
  for (int i = 0; i < rows * columns; i++) {
    data[i].red = gen() % 256;
    data[i].green = gen() % 256;
    data[i].blue = gen() % 256;
  }
  return data;
}
std::vector<rgb_coub> Gaussian_Filter_Seq(const std::vector<rgb_coub>& img,
                                          int rows, int columns,
                                          const double sigma) {
  if (columns <= 0 || rows <= 0 || img.size() == 0 || sigma == 0.0) {
    throw "-1";
  }
  double norm = 0.0;
  double r, g, b;
  double Gaussian_Kernel[3][3];
  for (int x = -1; x < 2; x++) {
    for (int y = -1; y < 2; y++) {
      Gaussian_Kernel[x + 1][y + 1] =
          std::exp(-(x * x + y * y) / (2 * pow(sigma, 2)));
      norm += Gaussian_Kernel[x + 1][y + 1];
    }
  }
  for (int x = -1; x < 2; x++) {
    for (int y = -1; y < 2; y++) {
      Gaussian_Kernel[x + 1][y + 1] /= norm;
    }
  }
  std::vector<rgb_coub> result(rows * columns);
  int x, y;
  for (int i = 0; i < columns; i++) {
    for (int j = 0; j < rows; j++) {
      r = g = b = 0.0;
      for (int k = -1; k < 2; k++) {
        for (int n = -1; n < 2; n++) {
          x = n + j;
          y = k + i;

          if (x > rows - 1 || x < 0) {
            x = j;
          }
          if (y > columns - 1 || y < 0) {
            y = i;
          }
          r += static_cast<double>(img[x * columns + y].red) *
               Gaussian_Kernel[k + 1][n + 1];
          g += static_cast<double>(img[x * columns + y].green) *
               Gaussian_Kernel[k + 1][n + 1];
          b += static_cast<double>(img[x * columns + y].blue) *
               Gaussian_Kernel[k + 1][n + 1];
        }
      }
      result[j * columns + i].red = static_cast<unsigned char>(r);
      result[j * columns + i].green = static_cast<unsigned char>(g);
      result[j * columns + i].blue = static_cast<unsigned char>(b);
    }
  }
  return result;
}

std::vector<rgb_coub> Gaussian_Filter_Tbb(const std::vector<rgb_coub>& img,
                                          int rows, int columns,
                                          const double sigma) {
  if (columns <= 0 || rows <= 0 || img.size() == 0 || sigma == 0.0) {
    throw "-1";
  }
  double norm = 0.0;
  double Gaussian_Kernel[3][3];
  for (int x = -1; x < 2; x++) {
    for (int y = -1; y < 2; y++) {
      Gaussian_Kernel[x + 1][y + 1] =
          std::exp(-(x * x + y * y) / (2 * pow(sigma, 2)));
      norm += Gaussian_Kernel[x + 1][y + 1];
    }
  }
  for (int x = -1; x < 2; x++) {
    for (int y = -1; y < 2; y++) {
      Gaussian_Kernel[x + 1][y + 1] /= norm;
    }
  }
  std::vector<rgb_coub> result(rows * columns);
  tbb::parallel_for(
      tbb::blocked_range<int>(0, columns),
      [&](const tbb::blocked_range<int>& range) {
        double r, g, b;
        int x, y;
        for (int i = range.begin(); i != range.end(); ++i) {
          for (int j = 0; j < rows; j++) {
            r = g = b = 0.0;
            for (int k = -1; k < 2; k++) {
              for (int n = -1; n < 2; n++) {
                x = n + j;
                y = k + i;

                if (x > rows - 1 || x < 0) {
                  x = j;
                }
                if (y > columns - 1 || y < 0) {
                  y = i;
                }
                r += static_cast<double>(img[x * columns + y].red) *
                     Gaussian_Kernel[k + 1][n + 1];
                g += static_cast<double>(img[x * columns + y].green) *
                     Gaussian_Kernel[k + 1][n + 1];
                b += static_cast<double>(img[x * columns + y].blue) *
                     Gaussian_Kernel[k + 1][n + 1];
              }
            }
            result[j * columns + i].red = static_cast<unsigned char>(r);
            result[j * columns + i].green = static_cast<unsigned char>(g);
            result[j * columns + i].blue = static_cast<unsigned char>(b);
          }
        }
      });
  return result;
}
\end{lstlisting}
main.cpp
\begin{lstlisting}
// Copyright 2022 Sablin Alexandr
#include <gtest/gtest.h>

#include <algorithm>

#include "../../../modules/task_3/sablin_a_gaussian_vert/gaussian_vert.h"

TEST(Gaussian_Filter_vertical, Test_Zero_Pixels_and_Sigma) {
  std::vector<rgb_coub> img = getRandomImage(1, 1);
  EXPECT_ANY_THROW(Gaussian_Filter_Tbb(img, 0, 0, 1));
  EXPECT_ANY_THROW(Gaussian_Filter_Tbb(img, 0, 1, 1));
  EXPECT_ANY_THROW(Gaussian_Filter_Tbb(img, 1, 0, 1));
  EXPECT_ANY_THROW(Gaussian_Filter_Tbb(img, 1, 1, 0));
  EXPECT_ANY_THROW(getRandomImage(0, 0));
}

TEST(Gaussian_Filter_vertical, Test_Different_Rows_and_Columns) {
  int rows = 120, columns = 8;
  const double sigma = 2.0;
  std::vector<rgb_coub> image = getRandomImage(rows, columns);
  auto t1 = clock();
  std::vector<rgb_coub> res1 = Gaussian_Filter_Seq(image, rows, columns, sigma);
  auto t2 = clock();
  std::vector<rgb_coub> res2 = Gaussian_Filter_Tbb(image, rows, columns, sigma);
  auto t3 = clock();
  std::cout << "Time Seq: " << static_cast<float>(t2 - t1) / CLOCKS_PER_SEC
            << std::endl;
  std::cout << "Time Tbb: " << static_cast<float>(t3 - t2) / CLOCKS_PER_SEC
            << std::endl;
  std::cout << "Efficiency: "
            << (static_cast<float>(t2 - t1) / CLOCKS_PER_SEC) /
                   (static_cast<float>(t3 - t2) / CLOCKS_PER_SEC)
            << std::endl;
  ASSERT_EQ(res1, res2);
}

TEST(Gaussian_Filter_vertical, Test_Big_Image) {
  int rows = 300, columns = 300;
  const double sigma = 2.0;
  std::vector<rgb_coub> image = getRandomImage(rows, columns);
  auto t1 = clock();
  std::vector<rgb_coub> res1 = Gaussian_Filter_Seq(image, rows, columns, sigma);
  auto t2 = clock();
  std::vector<rgb_coub> res2 = Gaussian_Filter_Tbb(image, rows, columns, sigma);
  auto t3 = clock();
  std::cout << "Time Seq: " << static_cast<float>(t2 - t1) / CLOCKS_PER_SEC
            << std::endl;
  std::cout << "Time Tbb: " << static_cast<float>(t3 - t2) / CLOCKS_PER_SEC
            << std::endl;
  std::cout << "Efficiency: "
            << (static_cast<float>(t2 - t1) / CLOCKS_PER_SEC) /
                   (static_cast<float>(t3 - t2) / CLOCKS_PER_SEC)
            << std::endl;
  ASSERT_EQ(res1, res2);
}

TEST(Gaussian_Filter_vertical, Test_One_Pixel) {
  int rows = 1, columns = 1;
  const double sigma = 2.0;
  std::vector<rgb_coub> image = getRandomImage(rows, columns);
  std::vector<rgb_coub> copy(image);
  image = Gaussian_Filter_Tbb(image, rows, columns, sigma);
  ASSERT_EQ(image, copy);
}

TEST(Gaussian_Filter_vertical, Test_Const_Image) {
  int rows = 3, columns = 3;
  const double sigma = 2.0;
  std::vector<rgb_coub> true_result(rows * columns);
  true_result[0].red = true_result[0].green = true_result[0].blue = 85;
  true_result[1].red = true_result[1].green = true_result[1].blue = 99;
  true_result[2].red = true_result[2].green = true_result[2].blue = 112;
  true_result[3].red = true_result[3].green = true_result[3].blue = 126;
  true_result[4].red = true_result[4].green = true_result[4].blue = 140;
  true_result[5].red = true_result[5].green = true_result[5].blue = 153;
  true_result[6].red = true_result[6].green = true_result[6].blue = 167;
  true_result[7].red = true_result[7].green = true_result[7].blue = 180;
  true_result[8].red = true_result[8].green = true_result[8].blue = 194;
  std::vector<rgb_coub> image(rows * columns);
  for (int i = 0; i < rows * columns; i++) {
    image[i].red = 60 + i * 20;
    image[i].green = 60 + i * 20;
    image[i].blue = 60 + i * 20;
  }
  image = Gaussian_Filter_Tbb(image, rows, columns, sigma);
  ASSERT_EQ(image, true_result);
}

int main(int argc, char** argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
  return 0;
}

\end{lstlisting}

\textbf{std::thread версия}
\newline
\newline gaussian\_vert.h
\begin{lstlisting}
// Copyright 2022 Sablin Alexandr
#ifndef MODULES_TASK_4_SABLIN_A_GAUSSIAN_VERT_GAUSSIAN_VERT_H_
#define MODULES_TASK_4_SABLIN_A_GAUSSIAN_VERT_GAUSSIAN_VERT_H_

#include <ctime>
#include <iostream>
#include <random>
#include <vector>

struct rgb_coub {
  unsigned char red, green, blue;
};
bool operator==(const rgb_coub& a, const rgb_coub& b);
bool operator!=(const rgb_coub& a, const rgb_coub& b);
std::vector<rgb_coub> getRandomImage(int rows, int columns);
std::vector<rgb_coub> Gaussian_Filter_Seq(const std::vector<rgb_coub>& img,
                                          int rows, int columns,
                                          const double sigma);
std::vector<rgb_coub> Gaussian_Filter_Thread(const std::vector<rgb_coub>& img,
                                          int rows, int columns,
                                          const double sigma);

#endif  // MODULES_TASK_4_SABLIN_A_GAUSSIAN_VERT_GAUSSIAN_VERT_H_

\end{lstlisting}
gaussian\_vert.cpp
\begin{lstlisting}
// Copyright 2022 Sablin Alexandr
#include "../../../3rdparty/unapproved/unapproved.h"
#include "../../../modules/task_4/sablin_a_gaussian_vert/gaussian_vert.h"

bool operator==(const rgb_coub& a, const rgb_coub& b) {
  return (a.red == b.red) && (a.green == b.green) && (a.blue == b.blue);
}

bool operator!=(const rgb_coub& a, const rgb_coub& b) {
  return (a.red != b.red) && (a.green != b.green) && (a.blue != b.blue);
}

std::vector<rgb_coub> getRandomImage(int rows, int columns) {
  if (columns <= 0 || rows <= 0) {
    throw "-1";
  }
  std::random_device dev;
  std::mt19937 gen(dev());
  std::vector<rgb_coub> data(rows * columns);
  for (int i = 0; i < rows * columns; i++) {
    data[i].red = static_cast<unsigned char>(gen() % 256);
    data[i].green = static_cast<unsigned char>(gen() % 256);
    data[i].blue = static_cast<unsigned char>(gen() % 256);
  }
  return data;
}
std::vector<rgb_coub> Gaussian_Filter_Seq(const std::vector<rgb_coub>& img,
                                          int rows, int columns,
                                          const double sigma) {
  if (columns <= 0 || rows <= 0 || img.size() == 0 || sigma == 0.0) {
    throw "-1";
  }
  double norm = 0.0;
  double r, g, b;
  double Gaussian_Kernel[3][3];
  for (int x = -1; x < 2; x++) {
    for (int y = -1; y < 2; y++) {
      Gaussian_Kernel[x + 1][y + 1] =
          std::exp(-(x * x + y * y) / (2 * pow(sigma, 2)));
      norm += Gaussian_Kernel[x + 1][y + 1];
    }
  }
  for (int x = -1; x < 2; x++) {
    for (int y = -1; y < 2; y++) {
      Gaussian_Kernel[x + 1][y + 1] /= norm;
    }
  }
  std::vector<rgb_coub> result(rows * columns);
  int x, y;
  for (int i = 0; i < columns; i++) {
    for (int j = 0; j < rows; j++) {
      r = g = b = 0.0;
      for (int k = -1; k < 2; k++) {
        for (int n = -1; n < 2; n++) {
          x = n + j;
          y = k + i;

          if (x > rows - 1 || x < 0) {
            x = j;
          }
          if (y > columns - 1 || y < 0) {
            y = i;
          }
          r += static_cast<double>(img[x * columns + y].red) *
               Gaussian_Kernel[k + 1][n + 1];
          g += static_cast<double>(img[x * columns + y].green) *
               Gaussian_Kernel[k + 1][n + 1];
          b += static_cast<double>(img[x * columns + y].blue) *
               Gaussian_Kernel[k + 1][n + 1];
        }
      }
      result[j * columns + i].red = static_cast<unsigned char>(r);
      result[j * columns + i].green = static_cast<unsigned char>(g);
      result[j * columns + i].blue = static_cast<unsigned char>(b);
    }
  }
  return result;
}

std::vector<rgb_coub> Gaussian_Filter_Thread(const std::vector<rgb_coub>& img,
                                             int rows, int columns,
                                             const double sigma) {
  if (columns <= 0 || rows <= 0 || img.size() == 0 || sigma == 0.0) {
    throw "-1";
  }
  double norm = 0.0;
  double Gaussian_Kernel[3][3];

  for (int x = -1; x < 2; x++) {
    for (int y = -1; y < 2; y++) {
      Gaussian_Kernel[x + 1][y + 1] =
          std::exp(-(x * x + y * y) / (2 * pow(sigma, 2)));
      norm += Gaussian_Kernel[x + 1][y + 1];
    }
  }
  for (int x = -1; x < 2; x++) {
    for (int y = -1; y < 2; y++) {
      Gaussian_Kernel[x + 1][y + 1] /= norm;
    }
  }
  const int nthreads =
      std::thread::hardware_concurrency();
  std::thread* threads =
      new std::thread[nthreads];

  const int delta = columns / nthreads;
  int residue = columns % nthreads;

  int my_begin, my_end = 0;
  std::vector<rgb_coub> result(img.size());
  for (int k = 0; k < nthreads; k++) {
    my_begin = my_end;
    my_end += delta;
    if (residue > 0) {
      my_end++;
      residue--;
    }
    threads[k] = std::thread(
        [&](int begin, int end) {
          double r, g, b;
          int x, y;
          for (int i = begin; i < end; i++) {
            for (int j = 0; j < rows; j++) {
              r = g = b = 0.0;
              for (int k = -1; k < 2; k++) {
                for (int n = -1; n < 2; n++) {
                  x = n + j;
                  y = k + i;

                  if (x > rows - 1 || x < 0) {
                    x = j;
                  }
                  if (y > columns - 1 || y < 0) {
                    y = i;
                  }
                  r += static_cast<double>(img[x * columns + y].red) *
                       Gaussian_Kernel[k + 1][n + 1];
                  g += static_cast<double>(img[x * columns + y].green) *
                       Gaussian_Kernel[k + 1][n + 1];
                  b += static_cast<double>(img[x * columns + y].blue) *
                       Gaussian_Kernel[k + 1][n + 1];
                }
              }
              result[j * columns + i].red = static_cast<unsigned char>(r);
              result[j * columns + i].green = static_cast<unsigned char>(g);
              result[j * columns + i].blue = static_cast<unsigned char>(b);
            }
          }
        },
        my_begin, my_end);
  }

  for (int i = 0; i < nthreads; ++i) {
    threads[i].join();
  }

  delete[] threads;
  return result;
}
\end{lstlisting}
main.cpp
\begin{lstlisting}
// Copyright 2022 Sablin Alexandr
#include <gtest/gtest.h>
#include "../../../modules/task_4/sablin_a_gaussian_vert/gaussian_vert.h"

TEST(Gaussian_Filter_vertical, Test_Zero_Pixels_and_Sigma) {
  std::vector<rgb_coub> img = getRandomImage(1, 1);
  EXPECT_ANY_THROW(Gaussian_Filter_Thread(img, 0, 0, 1));
  EXPECT_ANY_THROW(Gaussian_Filter_Thread(img, 0, 1, 1));
  EXPECT_ANY_THROW(Gaussian_Filter_Thread(img, 1, 0, 1));
  EXPECT_ANY_THROW(Gaussian_Filter_Thread(img, 1, 1, 0));
  EXPECT_ANY_THROW(getRandomImage(0, 0));
}

TEST(Gaussian_Filter_vertical, Test_Different_Rows_and_Columns) {
  int rows = 120, columns = 8;
  const double sigma = 2.0;
  std::vector<rgb_coub> image = getRandomImage(rows, columns);
  auto t1 = clock();
  std::vector<rgb_coub> res1 =
      Gaussian_Filter_Seq(image, rows, columns, sigma);
  auto t2 = clock();
  std::vector<rgb_coub> res2 =
      Gaussian_Filter_Thread(image, rows, columns, sigma);
  auto t3 = clock();
  std::cout << "Time Seq: " << static_cast<float>(t2 - t1) / CLOCKS_PER_SEC
            << std::endl;
  std::cout << "Time Thread: " << static_cast<float>(t3 - t2) / CLOCKS_PER_SEC
            << std::endl;
  std::cout << "Efficiency: "
            << (static_cast<float>(t2 - t1) / CLOCKS_PER_SEC) /
                   (static_cast<float>(t3 - t2) / CLOCKS_PER_SEC)
            << std::endl;
  ASSERT_EQ(res1, res2);
}

TEST(Gaussian_Filter_vertical, Test_Big_Image) {
  int rows = 300, columns = 300;
  const double sigma = 2.0;
  std::vector<rgb_coub> image = getRandomImage(rows, columns);
  auto t1 = clock();
  std::vector<rgb_coub> res1 =
      Gaussian_Filter_Seq(image, rows, columns, sigma);
  auto t2 = clock();
  std::vector<rgb_coub> res2 =
      Gaussian_Filter_Thread(image, rows, columns, sigma);
  auto t3 = clock();
  std::cout << "Time Seq: " << static_cast<float>(t2 - t1) / CLOCKS_PER_SEC
            << std::endl;
  std::cout << "Time Thread: " << static_cast<float>(t3 - t2) / CLOCKS_PER_SEC
            << std::endl;
  std::cout << "Efficiency: "
            << (static_cast<float>(t2 - t1) / CLOCKS_PER_SEC) /
                   (static_cast<float>(t3 - t2) / CLOCKS_PER_SEC)
            << std::endl;
  ASSERT_EQ(res1, res2);
}

TEST(Gaussian_Filter_vertical, Test_One_Pixel) {
  int rows = 1, columns = 1;
  const double sigma = 2.0;
  std::vector<rgb_coub> image = getRandomImage(rows, columns);
  std::vector<rgb_coub> copy(image);
  image = Gaussian_Filter_Thread(image, rows, columns, sigma);
  ASSERT_EQ(image, copy);
}

TEST(Gaussian_Filter_vertical, Test_Const_Image) {
  int rows = 3, columns = 3;
  const double sigma = 2.0;
  std::vector<rgb_coub> true_result(rows * columns);
  true_result[0].red = true_result[0].green = true_result[0].blue = 85;
  true_result[1].red = true_result[1].green = true_result[1].blue = 99;
  true_result[2].red = true_result[2].green = true_result[2].blue = 112;
  true_result[3].red = true_result[3].green = true_result[3].blue = 126;
  true_result[4].red = true_result[4].green = true_result[4].blue = 140;
  true_result[5].red = true_result[5].green = true_result[5].blue = 153;
  true_result[6].red = true_result[6].green = true_result[6].blue = 167;
  true_result[7].red = true_result[7].green = true_result[7].blue = 180;
  true_result[8].red = true_result[8].green = true_result[8].blue = 194;
  std::vector<rgb_coub> image(rows * columns);
  for (int i = 0; i < rows * columns; i++) {
    image[i].red = 60 + i * 20;
    image[i].green = 60 + i * 20;
    image[i].blue = 60 + i * 20;
  }
  image = Gaussian_Filter_Thread(image, rows, columns, sigma);
  ASSERT_EQ(image, true_result);
}

int main(int argc, char** argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
  return 0;
}
\end{lstlisting}

\end{document}
